# В испытании "Чанкование" вам нужно было реализовать функцию, которая "нарезает" входную последовательность (любой iterable) на куски заданной длины. В этом же испытании вам нужно будет проделать нечто подобное, но уже с итератором — потенциально бесконечным! Иначе говоря, вам предстоит обрабатывать поток данных. Примерами таких потоков могут быть читаемый с диска файл очень большого размера или данные видео-трансляции, передаваемые по сети. В обоих случаях вы не можете себе позволить получить все данные сразу в виде структуры в памяти — вам её просто не хватит. И поэтому же вы не можете накапливать список кусочков внутри вашей функции, вам нужно возвращать поток кусочков.

# src/solution.py
# Реализуйте функцию ichunks, которая должна принимать в качестве аргументов размер кусочка (положительное целое число) и источник данных (итератор). Вернуть функция должна итератор списков заданной длины, содержащих элементы из источника данных.

# Внимание, в этот раз вам нужно будет формировать куски строго заданной длины! Если для последнего куска (если поток вообще закончится) не хватит элементов, то весь кусок отбрасывается!

# Примеры применения функции:

# >>> list(ichunks(2, [1, 2, 3, 4, 5]))
# [[1, 2], [3, 4]]
# >>> # ^ пятёрка была отброшена
# >>>
# >>> import itertools
# >>> # itertools.count() - бесконечный поток чисел 1, 2, 3...
# >>> list(itertools.islice(itertools.count(), 10000, 10005))
# [10000, 10001, 10002, 10003, 10004]
# >>>
# >>> stream = ichunks(3, itertools.count())  # поток троек чисел
# >>> list(itertools.islice(stream, 10000, 10002))
# [[30000, 30001, 30002], [30003, 30004, 30005]]
# Возможно, вы отметили, что имя функции начинается с "i" и отрезает то, что будет содержать возвращаемый итератор. Такое имя выбрано неспроста: похожим образом нередко именуют функции, работающие с итераторами. Например, несколько функций из стандартного модуля itertools названы в этом стиле.

# Замечания
# У нас, увы, нет возможности проверить код на переполнение памяти. Поэтому мы полагаемся на вашу ответственность. Если вы вернёте что-то вроде iter(huge_list), тесты будут пройдены, но такое решение не будет по-настоящему правильным!

# Подсказки
# Чтобы вернуть итератор, воспользуйтесь при решении функциями, которые уже возвращают итераторы: map, zip, функции из модуля itertools.

def ichunks(size, source):
    return map(list, zip(*([iter(source)] * size)))
    # "iter(source)" получает именно итератор, даже если на вход
    # был передан iterable (строка, список).
    #
    # "[iterator] * n" размножает ссылки на итератор.
    #
    # "zip(*l)" пакует в кортежи все первые элементы из
    # списка источников "l", затем все вторые, и так далее.
    # Так как все источники для zip, это ссылки на один и тот же
    # итератор, при переходе от ссылки к ссылке курсор передвигается
    # всё дальше. Поэтому кортежи содержат последовательные элементы.

# def ichunks(size, iterable):
#     stream = iter(iterable)
#     template = [stream] * size
#     return map(list, zip(*template))

# def ichunks(size, data):
#     it = iter(data)
#     chunk = []
#     while True:
#         try:
#             chunk = []
#             for _ in range(size):
#                 chunk.append(next(it))
#             if len(chunk) == size:
#                 yield chunk
#         except StopIteration:
#             return

# def ichunks(value, stream):
#     i = iter(stream)
#     while True:
#         try:
#             yield [next(i) for _ in range(value)]
#         except StopIteration:
#             break

# def ichunks(chunk, sequence):
#     iter_sequence = [iter(sequence)] * chunk
#     return map(list, zip(*iter_sequence))