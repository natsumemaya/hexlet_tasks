# Как вы уже знаете, в Python многое работает на основе протоколов. Обращение по индексу или ключу — через те самые квадратные скобки — тоже работает с любыми объектами, реализующими "subscription protocol".

# Этот протокол требует, чтобы у объекта имелись нужного вида методы __getitem__ и __setitem__, первый из которых позволяет получить значение по ключу или индексу, а второй сохранить значение по указанному ключу. Вот так эти методы работают для словаря:

# >>> d = {}
# >>> d = {'a': 42}
# >>> d.__getitem__('a')       # то есть d['a']
# 42
# >>> d.__setitem__('a', 100)  # то есть d['a'] = 100
# >>> d
# {'a': 100}
# >>> d.__setitem__('a', d.__getitem__('a') + 5)
# >>> # а это уже d['a'] += 5
# Подробнее о методах можно почитать здесь:

# getitem
# setitem
# src/solution.py
# Вам нужно реализовать класс MultiKeyDict, который должен уметь работать по протоколу __getitem__/__setitem__.

# Класс принимает именованные параметры, которые становятся первыми ключами и значениями. В этом класс максимально похож на dict. А вот метод alias уже является отличием: вызывая этот метод с параметрами "новый_ключ='старый_ключ'", вы создаёте псевдонимы для существующих ключей.

# Обращение по созданному псевдониму ничем не отличается от обращения по оригинальному ключу, то есть с момента создания псевдонима у значения становится два ключа (или больше, конечно же).

# Важно, что с помощью метода alias должно быть возможно "перекинуть" старые ключи на новые значения без потери этих самых значений, если останется хотя бы один псевдоним, всё ещё ссылающийся на значение.

# При перебрасывании последнего ключа, некие значения могут остаться вообще без ключа. По условиям задачи вам не нужно производить чистку таких значений, но вы можете попробовать реализовать и такую функциональность!

# Примеры
# >>> mkd = MultiKeyDict(x=100, y=[10, 20])
# >>>
# >>> mkd.alias(z='x')  # 'z' теперь означает то же, что и 'x'
# >>> mkd['z']
# 100
# >>> mkd['z'] += 1  # Можно даже менять значение через присваивание,
# >>> mkd['x']       # что затронет и оригинальный ключ.
# 101
# >>> mkd.alias(z='y')  # Теперь 'z' уже равнозначен 'y'
# >>> mkd['z'] += [30]
# >>> mkd['y']
# [10, 20, 30]

class MultiKeyDict(object):
    """Словареподобный контейнер, позволяющий иметь псевдонимы ключей."""

    def __init__(self, **kwargs):
        """
        Инициализирует контейнер.

        Arguments:
            kwargs — пары "ключ-значение", которые будет содержать
            контейнер сразу после инициализации.

        """
        # BEGIN
        self._sequence = 0  # счётчик, используемый для промежуточных ключей
        self._keys = {}  # отображение внешних ключей во внутренние
        self._values = {}  # отображение внутренних ключей в значения
        for k, v in kwargs.items():
            self[k] = v
        # END

    def __getitem__(self, key):
        """
        Возвращает значение по ключу.

        Arguments:
        - key — один из ключей, связанных со значением.

        """
        # BEGIN
        return self._values[self._keys[key]]
        # END

    def __setitem__(self, key, value):
        """
        Сохраняет значение по указанному ключу.

        Изменение затрагивает все псевдонимы ключа. Любой из псевдонимов
        может быть указан в роли ключа.

        Arguments:
            key — ключ, по которому будет сохранено значение,
            value — сохраняемое по указанному ключу значение.

        """
        # BEGIN
        internal_key = self._keys.get(key)
        if internal_key is None:
            self._sequence += 1
            internal_key = self._sequence
            self._keys[key] = internal_key
        self._values[internal_key] = value
        # END

    def alias(self, **kwargs):
        """
        Добавляет псевдоним(ы) для существующих ключей.

        Arguments:
            kwargs — пары "новый ключ - старый ключ". Все "старые ключи"
            должны уже присутствовать в контейнере.

        """
        # BEGIN
        for new_key, key in kwargs.items():
            self._keys[new_key] = self._keys[key]
            # Текущая реализация позволяет делать существующие ключи
            # псевдонимами для других существующих ключей.
            # Это может привести к "осиротению" некоторых значений —
            # значения могут потерять внешний ключ. Такие "сироты"
            # будут занимать память, но не будут доступны извне.
            # В реальном коде эту проблему пришлось бы решать,
            # для учебных же целей реализация годится и в таком виде.
        # END